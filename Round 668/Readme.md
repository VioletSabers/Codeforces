## Codeforces Round #668 (Div. 1)题解

### A. Balanced Bitstring

#### 题目大意：

给定一个长度为$n$的含有$?$的01串。现要往$?$处填入$0$或$1$，要求填完后的01串的每个长度为$k$的子串中，$0$和$1$的个数相同。

数据范围：$2 \leq k \leq n \leq 3 \cdot 10^5$，$k$是偶数

#### 题解：

因为对于任意的子串，都要求0的个数和1的个数相同。又因为子串长度固定，所以一定有$s[i+k]=s[i]$。

首先确定第一个子串是否可行，即前$k$个$01$构成的子串是否可以做到$0$和$1$个数相同。如果可行，首先构造出前$k$个的填写法，之后往后根据$s[i+k]=s[i]$的规则递推，判断是否可行并填写$?$位置。



### B. Tree Tag

#### 题目大意：

给一颗$n$个节点的树，Alice和Bob在树上的两个点上。Alice和Bob轮流走，Alice每次最多走 $a$，Bob每次最多走距离b。如果Alice走完后和Bob在同一个节点，则Alice胜利，如果Alice永远抓不到Bob，则Bob胜利。 

#### 题解：

如果Bob距离Alice的距离小于等于a，则Alice一步就可以抓到Bob，那Bob必然输，

如果A树的直径小于等于2a，则必然存在一个点，Alice站在这个点上的时候，无论Bob怎么走，下一步Alice一定能抓到Bob，则Bob必输

如果树的直径>2a但b<2a。这个时候Bob只会不断地被Alice往角落上逼，因为Bob无法穿过Alice到另外安全的点上。直到Bob无路可走输掉。这种情况也是Bob输。

只有在Alice一步无法抓到Bob，树的直径>2a，b>2a的时候，Bob可以胜利。



### C. Fixed Point Removal

#### 题目大意：

给定一个长度为$n$的正数序列$a_n$，每次可以删除一个数，这个数需要满足$a_i=i$。移除之后，前后两段序列重新拼接成新的序列。一共有$q$个询问，每次询问的时候，固定序列中前$l$个和后$r$个数（固定即不可删除，但数字仍然在序列中），问每个询问最多进行多少次操作。

数据范围：
$1 \leq n,q \leq 3 \cdot10^5，1 \leq a_i \leq n$



#### 题解：

对于每个数$a_i$，他的编号只会逐渐变小，不会增大 。所以，如果$a_i<i$，则这个数一定不能被删掉。

当$a_i>i$的时候，只有当他前面至少可以删除$a_i-i$个数的时候，才能被删除。

假设没有多组询问，只询问整个序列最多能被删除多少次。可以使用dp的方法去做。

另$f(i)$表示前$i$个数组成的序列最多被删除多少次

$f(i)=f(i-1)+[f(i-1)>=a_i-i][a_i>=i]$

我们假设一个二维的dp状态$f(i,j)$表示从$i$到$j$组成的序列最多被操作多少次（其他的数不是被删除而是被固定）。

考虑从$j$到$j+1$的过程中$f(1,j)$到$f(j,j)$哪些被更新了，我们更新的$f(i,j)$满足$f(i,j) \geq a_(j+1)-(j+1)$。并且由于$f(1,j)$到$f(j,j)$，能操作的次数单调递减，所以我们可以二分得到位置，之后区间+1使用线段树维护。

由于在线段树上操作，我们省去二分，直接在线段树中找到对应的位置，然后区间+1。

整个算法流程大致为，枚举右端点，线段树维护$f(i,j)$。对于多个询问，离线下来按照右端点排序，对应右端点处理完后按左端点查找结果。



### D.Game of Pairs.​

#### 题目大意：

交互题。给定正整数$n$，两个人进行游戏。

首先有$2 \cdot n$个数$1,2,3...2n$。第一个人将这个$2n$个数分成$n$组，每组两个数。

第二个人在$n$组中每组挑一个数，选出$n$个数。如果这$n$个数的和是$2n$的倍数，则第二个人获胜，否则第一个人获胜。

现在要求你选择当第一个人还是第二个人，并给出获胜方法。

数据范围：
$1 \leq n \leq 5 \cdot 10^5$

#### 题解：

这种当题目和n关系很大时，一般是按奇偶分类，4的余数分类，素数合数分类......

$n$为偶数的时候，我们可以1和n+1一组，2和n+2一组这样分

这样的话，每组的数模n的结果一样，最终的和模n就是$\frac{n(n+1)}{2}$，n是偶数这个数就是奇数，一定不是$2*n$的倍数

$n$为奇数的时候，我们选择玩家2。也用同样的思路，我们如果能取出模n余0，模n余1，模n余2的数各一个，最终的和一定可以是$n$的倍数，如果不是$2*n$的倍数，我们就选择我们当前选择集合的补集，一定也满足条件，并且和是$2*n$的倍数

这是由于1加到$2n$的结果是$(1+2\cdot n)\cdot n$。如果我们选的集合的和不是$2*n$的倍数但是$n$的倍数，假设是$kn$（$k$为奇数），那么补集的和是$(1+2\cdot n-k)n$，这一定是$2\cdot n$的倍数

那么，如果取出模n是$1-n$的数。

我们将每组看成一个点，模$n=0$的两个数所在的两个点连边（在同一个组就是自环），模$n=1$的两个数所在的两个点连边......最后每个点的度都是2。

每个长为$k$的环中，都包含模$n$后$k$个不同的数，每组中选一个，不重复选$k$个即可。



### E. Bricks

#### 题目大意：

给一个$n \times m$的方格阵，有些位置有障碍物。使用$1 \times x$或者$x \times 1$的方块覆盖，问最少需要多少块方块才能完全覆盖。

数据范围：$1 \leq n,m \leq 200$

#### 题解：

没做出来，看题解的。

建立二分图。

将每个没有障碍物的两个相邻方格的边看成点，横边和相邻的纵边连边。横边一组，纵边一组，可以将图看成一个二分图。

原图肯定可以使用一些$1 \times 1$的方格覆盖，现在我们要擦去一些方格之间的边，使得多个$1 \times 1$的方格连成$1 \times n$的方格或者$n \times 1$的方格。转换到二分图中，就是选择最多的点，这些点对应的边被擦除。为了不产生拐弯的方块，我们要求选择的点不相邻，转化成二分图中最大点独立集问题。

最大点独立集=最小边覆盖=点数-最大匹配

最小点覆盖=最大匹配
