# 题解
## A. Journey Planning

**题意**：输入$n$个数$b_i$，要求找到一个$b$的一个子序列$b_{c_1},b_{c_2}...b_{c_k}$，使得$c_{i+1}-c_i=b_{c_{i+1}}-b_{c_i}$的同时，子序列的综合最大，输出最大值

**数据范围**：$n \leq 2 \cdot 10^5, b_i \leq 4 \cdot 10^5$

**题解**：对于每个$i$，$s[b_i-i]+=b_i$，之后s中的最大值便为答案



## B. Navigation System

**题意**：给一个有向图，每条边长度为1。开始给定一条从$s$到$t$的路径。有一个导航仪，每次从一个点到另一个点，如果走的路径是导航仪给的路径，则导航仪导航线路不变，否则导航仪会重新从新的节点出发找一条到达$t$的最短路径。问从$s$到$t$的过程中，导航仪最少/最多修改多少次路径。

**数据范围**：$2\leq n,m \leq 2 \cdot 10^5$，给定的$s$到$t$的路径保证没有重点

**题解**：从终点开始沿向边bfs，找到所有点到终点的最短路径长度$d[i]$。对于路径上的每一小段$u \rightarrow v$

​	如果$d[v]!=d[u]+1$，则最小次数++

​	如果存在超过一个$w$，使得$d[w]==d[u]+1$或者只有一个$w$使得$d[w]==d[u]+1$但$w!=v$，则最大次数++



## C. World of Darkraft: Battle for Azathoth

**题意**：有$n$种武器和$m$种防具，每种武器攻击力为$a_i$，花费为$ca_i$，每种防具防御力为$b_i$，花费为$cb_i$。有$p$种怪物，每种怪物的防御力为$x_i$，攻击力为$y_i$，获得的收益为$z_i$。现在要挑一个武器和一个防具去打怪物。能打过的怪物为
<center>武器攻击力>怪物防御力并且防具防御力大于武器攻击力</center>
问最大能获得的利润（总收益-总花费）

**数据范围**：$1 \leq n,m,p \leq 2 \cdot 10^5，1 \leq a_i, b_i, x_i, y_i \leq 10^6，1 \leq ca_i, cb_i \leq 10^9， 1 \leq z_i \leq 10^3$

**题解**：按武器的攻击力从小到大枚举，将防御力小于当前枚举武器攻击力的怪物加入集合。那么现在只需要考虑选择哪个防具利润最高。每个防具的利润为集合中所有攻击力小于该防具防御力的怪物的收益之和减去防具的花费。使用线段树维护防御力。每加入一个怪物，相当于对线段树上1到该怪物攻击力量的点增加收益。询问就是问整个区间最大值。防具的花费在建立线段树的时候初始化进去，收益相当于附负数。有些防御力的值没有对应防具，收益为负无穷。

PS：初始化的时候注意，对于防御力相同的防具，选择花费较低的防具。

## D. Reachable Strings
**题意**：给定一个长度为$n$的$01$字符串，一次操作可以将一段连续的‘011’翻转成‘110’或者将‘110‘翻转成’011‘。之后$q$个询问，每次询问给定字符串中两个相同长度的子串。问是否可以通过一系列操作，将其中一个子串转化为另一个子串。
**数据范围**：$1 \leq 2*10^5，1 \leq q \leq2*10^5$

**题解**：通过观察我们发现，如果某一段连续的1的个数为偶数个，那么这段1可以两两一组被移动到任意位置，如果某一段中含有奇数个1，那么不论怎么移动。这一段中的1的个数永远是奇数。猜测结论：首先两个串01个数需要相同，其次，对于每个0来说，统计其前面1的个数的奇偶性。如果两个串的每个0奇偶性都相同，则可以相互变化，否则不行。
具体做法，可以使用hash判断两个奇偶串是否相同，hash使用三进制双hash即可
PS：如果两个串前面的1的个数奇偶性不同，需要翻转就行求hash


## E. Treeland and Viruses
**题意**：给定一棵$n$个节点的树，以及q个询问，每个询问给出$k_i$个病毒和$m_i$个重要城市。开始的时候每种病毒会在某些城市，并且每中病毒拥有自己的传播速度。在每轮传播中，从1号病毒开始到$k_i$号病毒轮流传播。每次传播，如果某个城市$y$与一个已被该病毒感染的城市距离小于等于该病毒的传播速度，并且中间没有被其他病毒感染的城市，那么这个城市$y$就会感染该病毒。问最后这些重要城市分别被几号病毒感染。

**数据范围**：$1 \leq n, q \leq 2*10^5，\sum_{i=1}^q k_i，\sum_{i=1}^q m_i \leq 2*10^5$

**题解**：因为多组询问，不能每次都遍历整棵树。所以建立压缩树，压缩树就是把所有关键点和关键点两两的LCA加入早树中。做法为首先遍历树，得到所有点的dfs序，之后把所有关键点按dfs序排序。之后把相邻dfs序的两点的LCA加入关键点集合，去重，再按dfs序排序。之后每个点向离自己最近的祖先节点建边得到压缩树。

得到压缩树之后我通过树形dp寻找最优解，每个节点染上的病毒只可能是自己原本的或者从孩子节点的某一个传上来或者从父节点传下来。树形dp解决自下而上的传播，再dfs一次解决自上而下的传播即可。

## F. Blocks and Sensors
**题意**：给定一个$n*m*k$的三位空间，给定从6个方向看到的视图，视图中包含每个块的颜色情况。问是否存在一种在空间中放置有色$1*1*1$小方块的方法，使得6个方向的视图为给定的视图

**数据范围**：$1 \leq n*m*m \leq 2*10^5$

**题解**：先假设所有方块都在表面上，然后向各自方向推。需要讨论每个方块放的位置是否可行，多个方块被推到同一位置，是合并成一个方块还是否继续往后退还是保留一个其余继续往后退。讨论清楚即可。（写的时候情况挺多挺晕的。。。）
