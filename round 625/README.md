
## D. Reachable Strings
**题意**：给定一个长度为$n$的$01$字符串，一次操作可以将一段连续的‘011’翻转成‘110’或者将‘110‘翻转成’011‘。之后$q$个询问，每次询问给定字符串中两个相同长度的子串。问是否可以通过一系列操作，将其中一个子串转化为另一个子串。

**数据范围**：$1 \leq 2*10^5，1 \leq q \leq 2*10^5$

**题解**：通过观察我们发现，如果某一段连续的1的个数为偶数个，那么这段1可以两两一组被移动到任意位置，如果某一段中含有奇数个1，那么不论怎么移动。这一段中的1的个数永远是奇数。猜测结论：首先两个串01个数需要相同，其次，对于每个0来说，统计其前面1的个数的奇偶性。如果两个串的每个0奇偶性都相同，则可以相互变化，否则不行。
具体做法，可以使用hash判断两个奇偶串是否相同，hash使用三进制双hash即可
PS：如果两个串前面的1的个数奇偶性不同，需要翻转就行求hash


## E. Treeland and Viruses
**题意**：给定一棵$n$个节点的树，以及q个询问，每个询问给出$k_i$个病毒和$m_i$个重要城市。开始的时候每种病毒会在某些城市，并且每中病毒拥有自己的传播速度。在每轮传播中，从1号病毒开始到$k_i$号病毒轮流传播。每次传播，如果某个城市$y$与一个已被该病毒感染的城市距离小于等于该病毒的传播速度，并且中间没有被其他病毒感染的城市，那么这个城市$y$就会感染该病毒。问最后这些重要城市分别被几号病毒感染。

**数据范围**: $1 \leq n, q \leq 2*10^5，\sum_{i=1}^q k_i，\sum_{i=1}^q m_i \leq 2*10^5$

**题解**：因为多组询问，不能每次都遍历整棵树。所以建立压缩树，压缩树就是把所有关键点和关键点两两的LCA加入早树中。做法为首先遍历树，得到所有点的dfs序，之后把所有关键点按dfs序排序。之后把相邻dfs序的两点的LCA加入关键点集合，去重，再按dfs序排序。之后每个点向离自己最近的祖先节点建边得到压缩树。

得到压缩树之后我通过树形dp寻找最优解，每个节点染上的病毒只可能是自己原本的或者从孩子节点的某一个传上来或者从父节点传下来。树形dp解决自下而上的传播，再dfs一次解决自上而下的传播即可。

## F. Blocks and Sensors
**题意**：给定一个$n*m*k$的三位空间，给定从6个方向看到的视图，视图中包含每个块的颜色情况。问是否存在一种在空间中放置有色$1*1*1$小方块的方法，使得6个方向的视图为给定的视图

**数据范围**：$1 \leq n*m*m \leq 2*10^5$

**题解**：先假设所有方块都在表面上，然后向各自方向推。需要讨论每个方块放的位置是否可行，多个方块被推到同一位置，是合并成一个方块还是否继续往后退还是保留一个其余继续往后退。讨论清楚即可。（写的时候情况挺多挺晕的。。。）
